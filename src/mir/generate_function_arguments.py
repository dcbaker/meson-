#!/usr/bin/env python
# SPDX-License-Identifier: Apache-2.0
# Copyright © 2024 Intel Corporation

from __future__ import annotations
import argparse
import dataclasses
import enum
import sys
import typing as T
import xml.etree.ElementTree as et

from mako.template import Template
from mako import exceptions

if T.TYPE_CHECKING:

    class Arguments(T.Protocol):
        input: str
        header: str
        code: str


HEADER_TEMPLATE = '''\
// Copyright © 2024 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

// This file is autogenerated, do not edit.

#pragma once

#include "exceptions.hpp"
#include "meson/state/state.hpp"
#include "mir.hpp"
#include "passes/private.hpp"

#include <optional>
#include <string>
#include <unordered_set>
#include <vector>

namespace MIR::Passes::ArgumentValidator {

% for function in functions:
    struct ${function.struct_name} {
      % for pos in function.positional:
        MIR::${pos.type.value} ${pos.name};
      % endfor
      % for pos in function.optional:
        % if pos.default is None:
        std::optional<MIR::${pos.type.value}> ${pos.name};
        % else:
        MIR::${pos.type.value} ${pos.name};
        % endif
      % endfor
      % if function.variadic:
        std::vector<MIR::${function.variadic.type.value if function.variadic.convert is None else function.variadic.convert.value}> ${function.variadic.name};
      % endif
      % if function.keywords:
        struct {
          % for kw in function.keywords:
            % if kw.default is not None:
            ${kw.type.value} ${kw.name};
            % else:
            std::optional<${kw.type.value}> ${kw.name};
            % endif
          % endfor
        } keywords;
      % endif
    };

    ${function.struct_name}
    parse_${function.name}(const MIR::FunctionCall & func, const State::Persistant & state);

% endfor
} // MIR::Passes::ArgumentValidator

'''

CODE_TEMPLATE = '''\
<%!
    import os
%>
// Copyright © 2024 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

// This file is autogenerated, do not edit.

#include "${os.path.basename(header)}"
#include "passes/argument_extractors.hpp"

namespace MIR::Passes::ArgumentValidator {

namespace {

MIR::File src_to_file(const MIR::Instruction & raw_src, const State::Persistant & pstate,
                      const std::string & subdir, const std::string & name) {
    if (std::holds_alternative<MIR::String>(*raw_src.obj_ptr)) {
        const auto & src = std::get<MIR::String>(*raw_src.obj_ptr);
        return File{src.value, subdir, false, pstate.source_root, pstate.build_root};
    }
    if (std::holds_alternative<MIR::File>(*raw_src.obj_ptr)) {
        return std::get<MIR::File>(*raw_src.obj_ptr);
    }
    throw Util::Exceptions::InvalidArguments{
        "'" + name + "':" + " sources must be strings, files, or custom_target objects."};
}

std::vector<MIR::File>
srcs_to_files(std::vector<MIR::Instruction>::const_iterator begin,
              std::vector<MIR::Instruction>::const_iterator end,
              const FunctionCall & func,
              const State::Persistant & pstate) {
    std::vector<File> files{};
    std::transform(begin, end, std::back_inserter(files),
                   [&](const MIR::Instruction & i) { return src_to_file(i, pstate, func.source_dir, func.name); });
    return files;
}

} // namespace

% for function in functions:
    ${function.struct_name}
    parse_${function.name}(const FunctionCall & func, const State::Persistant & pstate) {
        if (func.pos_args.size() < ${function.min_pos_args}) {
            throw Util::Exceptions::InvalidArguments(
                "${function.name}: Expects ${function.min_pos_args} positional arguments, but received "
                 + std::to_string(func.pos_args.size()));
        }

      % if function.max_pos_args is not None:
        if (func.pos_args.size() > ${function.max_pos_args}) {
            throw Util::Exceptions::InvalidArguments(
                "${function.name}: Expects at least ${function.max_pos_args} positional arguments, but received "
                 + std::to_string(func.pos_args.size()));
        }
      % endif

      % if function.keywords:
        const std::unordered_set<std::string> valid_keywords = {
            ${", ".join(f'"{n}"' for n in function.keywords)}
        };
        for (const auto & [name, _] : func.kw_args) {
            if (!(valid_keywords.find(name) == valid_keywords.end())) {
                throw Util::Exceptions::InvalidArguments{
                    "${function.name}: Unexpected keyword argument: " + name};
            }
        }
      % endif

        // TODO: validate keyword arguments

      % if function.positional or function.optional or function.variadic:
        auto pos_args = func.pos_args.begin();
      % endif

        return ${function.struct_name} {
          % for pos in function.positional:
            .${pos.name} = extract_positional_argument<${pos.type.value}>(
              *(pos_args++)->obj_ptr,
              "${pos.name}: argument must be a ${pos.type.name.lower()}"),
          % endfor
          % for pos in function.optional:
            ## TODO: this looses the type validation
            .${pos.name} = (pos_args == func.pos_args.end()
              % if pos.default is not None:
                ? ${pos.type.value}{${pos.default}}
              % else:
                ? std::nullopt
              % endif
                : extract_positional_argument<${pos.type.value}>(
                    *(pos_args++)->obj_ptr)
              % if pos.default is not None:
                    .value_or(${pos.type.value}{${pos.default}})
              % endif
                    ),
          % endfor
          % if function.variadic is not None:
            .${function.variadic.name} =
              % if function.variadic.convert:
                % if function.variadic.convert is ArgumentType.FILE:
                srcs_to_files(pos_args, func.pos_args.end(), func, pstate),
                % endif
              % else:
                extract_variadic_arguments<${function.variadic.type.value}>(
                    pos_args, func.pos_args.end(),
                    "${function.variadic.name}: arguments must be strings"),
              % endif
          % endif
          % if function.keywords:
            .keywords = {
              % for kw in function.keywords:
                .${kw.name} = extract_keyword_argument<${kw.type.value}>(
                        func.kw_args, "${kw.name}",
                        "${function.name}: ${kw.name} argument must be a ${kw.type.name.lower()}"
                % if kw.default is not None:
                    ).value_or(${kw.type.value}{${kw.default}}),
                % else:
                    ),
                % endif
              % endfor
            },
          % endif
        };

    }

% endfor
} // MIR::Passes::ArgumentValidator

'''

_T = T.TypeVar('_T')


class ArgumentType(enum.Enum):

    STRING = 'String'
    FILE = 'File'
    BOOL = 'Boolean'
    ARRAY_STRING = 'Array[String]'


@dataclasses.dataclass(slots=True)
class PositionalArgument:

    name: str
    type: ArgumentType
    default: str | None


@dataclasses.dataclass(slots=True)
class VariadicArgument:

    name: str
    type: ArgumentType
    convert: ArgumentType | None


@dataclasses.dataclass(slots=True)
class KeywordArgument:

    name: str
    type: ArgumentType
    default: str


@dataclasses.dataclass(slots=True)
class Function:

    name: str
    positional: list[PositionalArgument]
    optional: list[PositionalArgument]
    variadic: VariadicArgument | None
    keywords: list[KeywordArgument]

    @property
    def struct_name(self) -> str:
        return ''.join(n.capitalize() for n in self.name.split('_'))

    @property
    def min_pos_args(self) -> int:
        # Calculate based on min variadic args + number of positional args
        return 0

    @property
    def max_pos_args(self) -> int | None:
        # None is there is no limit
        # Calculate based on variadic arguments + positional arguments, including optional ones
        return None


def extract_attr(e: et.Element | None, attr: str) -> str:
    assert e is not None, 'required element is missing'
    val = e.get(attr)
    assert val is not None, 'required attribute is not set'
    return val


def parse_argument_type(raw: str) -> ArgumentType:
    return ArgumentType[raw.upper()]


def parse_value(raw: str, type_: ArgumentType) -> object:
    match type_:
        case ArgumentType.BOOL:
            val = raw.lower()
            assert val, f'invalid boolean string {raw!r}'
            return val
        case ArgumentType.STRING:
            return raw
        case _:
            raise RuntimeError('Not implemented')


def parse_variadic_arguments(element: et.Element | None) -> VariadicArgument | None:
    if element is None:
        return None

    var = element.find('argument')
    assert var is not None, 'variadic argument must have one argument node'

    return VariadicArgument(
        extract_attr(var, 'name'),
        parse_argument_type(extract_attr(var, 'type')),
        parse_argument_type(v) if (v := var.get('convert')) else None,
    )


def parse_keyword_arguments(element: et.Element | None) -> list[KeywordArgument]:
    if element is None:
        return []

    keywords: list[KeywordArgument] = []

    for var in element.findall('argument'):
        type_ = parse_argument_type(extract_attr(var, 'type'))
        keywords.append(KeywordArgument(
            extract_attr(var, 'name'),
            type_,
            parse_value(v, type_) if (v := var.get('default')) else None,
        ))

    return keywords


def parse_positional_arguments(element: et.Element | None) -> list[PositionalArgument]:
    if element is None:
        return []

    positional: list[PositionalArgument] = []

    for var in element.findall('argument'):
        type_ = parse_argument_type(extract_attr(var, 'type'))
        positional.append(PositionalArgument(
            extract_attr(var, 'name'),
            type_,
            parse_value(v, type_) if (v := var.get('default')) else None,
        ))

    return positional


def parse_xml(xmlfile: str) -> T.Iterator[Function]:
    xml = et.parse(xmlfile)
    for fxml in xml.findall('function'):
        yield Function(
            extract_attr(fxml, 'name'),
            parse_positional_arguments(fxml.find('./arguments/positional')),
            parse_positional_arguments(fxml.find('./arguments/optional')),
            parse_variadic_arguments(fxml.find('./arguments/variadic')),
            parse_keyword_arguments(fxml.find('./arguments/keyword')),
        )


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument('input', help='XML description file')
    parser.add_argument('header', help='Where to write the header file')
    parser.add_argument('code', help='Where to write the code file')
    args = T.cast('Arguments', parser.parse_args())

    try:
        description = list(parse_xml(args.input))
        with open(args.header, 'w', encoding='utf-8') as f:
            f.write(Template(HEADER_TEMPLATE).render(functions=description))
        with open(args.code, 'w', encoding='utf-8') as f:
            f.write(Template(CODE_TEMPLATE).render(
                header=args.header, functions=description,
                ArgumentType=ArgumentType))
    except Exception:
        print(exceptions.text_error_template().render(), file=sys.stderr)
        return 1

    return 0


if __name__ == "__main__":
	sys.exit(main())
